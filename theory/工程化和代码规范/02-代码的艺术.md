# 学习目标


1.  写代码，学校和公司有很大的不同
    -   学校：作业、实验室的项目
    -   公司：工业级的产品，对稳定性有非常高的要求
2.  消除误解
    -   程序员35岁危机
    -   996.icu怎么破
3.  建立正确的意识
    -   知和行，那个更重要：一样重要，两者相辅相成
    -   很多人写了8~10年的代码，方法还是错的
4.  明确修炼的方向
    -   艺术品是由艺术家创造的
    -   艺术家的修炼是**有方法的**

 

# 一、相关概念讨论

## 软件工程是不只是需要写好代码！

-   软件工程师应该具有综合的素质
-   技术：
    -   编码能力、数据结构、算法
    -   系统结构、操作系统、计算机网络、分布式系统
-   产品：
    -   对业务的理解、交互设计、产品数据统计、产品/业务运营
-   项目管理
-   研究和创新



## Coding is Not easy

-   Coding的过程是：
    -   从**无序**变为**有序**
    -   将**现实世界中的问题**转化为**数据世界的模型**
    -   一个**认识**的过程（从**未知** 变为 **已知**）：刚开始实现一个业务的时候，你可能不是很了解，花费了一个月，你实现了这个功能，那你一定对这个功能非常了解
-   Coding的过程中，需要
    -   **把握问题**的能力
    -   **建立模型**的能力
    -   **沟通协作**的能力
    -   **编码执行**的能力
-   写好代码需要首先**建立品味**：知道什么样的代码是好代码、什么样的代码是烂代码



# 二、优秀代码的标准及来源

## 一流代码的特性

-   正确和性能
    -   鲁棒 Soild and Robust：代码正常执行，并且能处理各种意外的情况 
    -   高效 Fast：减少性能的浪费
-   可读和可维护
    -   简洁 Maintainable and Simple
    -   简短 Small
    -   可测试：做测试驱动开发是敏捷的前提
-   共享和重用
    -   共享 Re-usable：写完一次可以被很多项目使用，项目使用不可重用的代码，会增加代码量，这样不仅降低了软件的质量，更重要的是增加了软件的维护成本（这样越来越多的代码不是一个资产，而是一个债务）
    -   可移植 Proable：可以在多个平台上使用
-   运维和运营
    -   可监视 、可观测：可以从外部检测它的运行状态
    -   可运维：配置热加载
    -   可扩展：
        -   容量可扩展：请求量大的时候很容易通过扩张实例的方式来提高整个系统的容量
        -   功能可扩展：软件需要根据客户的需求迅速变化，需要对其扩展功能，所以对软件架构有很大的要求 



## Bad Code的一些表现

-   Bad function name
    -   do(), myFunc(), …….

-   Bad variable name
    -   a, b, c, temp

>   作用域越小可以使用越简单的名字

 

-   No comments
    -   太多人缺乏“讲故事”的能力
    -   先写注释后写代码
-   The Function has no single purpose 函数没有做到单一职责：代码会越来越不可维护
    -   **LoadFromFile**And**Calculate**()
    -   写完一个函数后，没法用简洁的语言说清楚这个函数是做什么的
-   Bad layout
    -   把所有的代码写为一行？
    -   Go语言统一布局：提交代码之前运行go fmt
-   程序不可测试：
    -   严重依赖手工测试
    -   不能快速的做回归测试



## 好的代码从哪里来

-   代码不只是“写”出来
    -   编码的时间一般只占用10%
-   好的代码是多个环节工作的结果
    -   编码前（经常被忽略或轻视的环节）
        -   需求分析、系统设计
    -   编码中
        -   编写代码，单元测试
        -   先写单测，再写代码
    -   编码后
        -   集成测试，上线，持续运营/ 迭代改进
-   一个好的系统/产品是以上过程**持续迭代**的结果



# 三、需求分析和系统设计

-   这是两个经常被忽视的环节
    -   太多人错误的认为，写代码才是最重要的事情
    -   太多项目，在没**搞清楚目标**之前，就开始编码了
    -   太多项目，在代码基本编写完成后，才发现**设计思路**是有问题的

-   前期多投入，收益更大
    -   除了开发，测试、上线和调试都是很大的成本
-   修改代码 VS 修改文档， 那个成本更高
    -   文档还写的很模糊就开始写代码
    -   因为你还没搞清楚问题，所以你在写代码的时候反复调整：**修改代码**
    -   首先把设计文档写清楚，直到我们通过阅读设计文档在脑海中已经有一个完整的系统，并且在设计中看不到太多有误解的地方，文档完成之后再去写代码：**修改文档**
    -   代码中涉及的逻辑远对于文档
-   需求分析、系统设计，差别是什么？
    -   需求分析：定义系统 / 软件 黑盒的行为（描述是什么）
    -   系统设计：设计系统 / 软件 白盒的机制（怎么工作的，为什么这么设计）



## 需求分析

-   问题：怎么用较短的几句话**勾勒**出一个系统的功能？
-   每个系统都有自己的定位：
    -   以GFS为例：GFS是一个用一般的硬件，给一些较大的集群提供有效率的、可靠的数据范问
-   怎么描述GFS的需求？
    -   分布式文档系统
    -   文件的数量；文件大小的分布；总的存储容量
    -   读写能力（读写文件次数，数据传输速率，读写延迟）
    -   容错能力；一致性方便的定位（强一致性、弱一致性）
    -   对外的接口（用户怎么使用）



## 需求分析的误区

1.  需求分析是产品经理的事情，和RD没有关系？

>   -   即使是偏用户产品的项目，RD也要参与需求评审；写软件是需要激情的，如果RD对软件功能的来龙去脉不了解，你不知道这个软件是为谁服务，就很难写好这个软件
>   -   在产品需求之外，RD需要整理系统的需求：

例如：对一个抽红包的功能，在整理需求方面RD和PM思路的不同。

PM：

-   整个游戏的规则
-   用户侧能看到的交互方式

RD：

-   系统的容量、并发、用户规模是怎么样的
-   系统的容错机制



2.  研发工程师在需求分析时，大量考虑系统实现细节；忽略需求分析，直奔系统设计，甚至代码实现细节

>   危害：
>
>   -   阻碍 需求分析 的聚焦
>   -   实现 决定 需求：你决定一个需求做或者不做，不是从用户的角度出发，而是从实现难度来决定

>   正确的做法：
>
>   -   从用户角度，确定需求：我们的产品最终是否能产生价值，最终决定与是否给用户解决他们的痛点
>   -   根据 投入产出比 确定开发优先级



## 需求分析的重要性

-   什么是导弹最有价值的模块？
    -   导航模块
    -   炸药
-   需求分析的地位
    -   导弹的 导航模块
-   现实情况
    -   有太多的炸药（开发资源）都爆炸在错误的地方了





## 系统设计

-   系统设计写什么？
    -   系统设计是一个过程，应该定义**架构、模块、结构和数据**，去满足特定的**需求**
-   系统设计的主要内容
    -   系统架构，模块设计，接口定义，数据定义
    -   关键算法，设计思路（why）
-   设计文档的分类
    -   总体设计文档
    -   子系统设计文档
    -   接口定义文档
    -   关键算法说明文档
    -   数据库设计文档

>   每个设计文档应该有各自的**主题**和**聚焦**
>
>   -   我们文档应该给谁去看？
>   -   将文档按照目的，所针对不同的阅读群体，切分多个不同的文档



## 系统架构

-   什么是系统架构 System Architecture
    -   系统架构是一个概念模型， 这个模型定义了系统结构、行为和更多视角细节
-   架构描述的几个要素
    -   静：系统如何组成，功能在这些组成部分之间如何划分
    -   动：各子系统如何联动，如何完成 任务/ 流程
    -   细：不同的角度，更详细的刻画出系统的全貌
-   系统架构在不同层次的体现
    -   总体设计：大系统的架构
    -   模块设计：子系统的架构



## 系统设计的方法

-   每个模块（子系统 / 模块）的功能都应该足够的**专注**和**单一**
    -   功能的单一是复用和扩展的基础
-   子系统/模块之间的关系应该简单而清晰
    -   软件中最复杂的是**耦合**（为什么全局变量是要极力避免的）
    -   子系统对外应该有非常明确的接口，其他子系统通过或者说仅仅通过接口去访问这些子系统，调用它们的功能
-   系统设计的**约束**
    -   资源的限制：计算、存储、IO/网络
-   需求是系统设计决策的来源
    -   在设计中，经常需要做权衡
    -   需求是做决策的重要依据
-   模型 / 抽象思维能力
    -   思考的重点：概念、模型、数据结构、算法
    -   脱离代码的细节：函数、语言

>   新同事来的时候完成一个串讲，通过阅读团队的相关代码和文档，之后开个会，有他来讲述对这个系统的理解，最后由组内的老同学提些问题。





## 推荐阅读

-   来自Google的三大系统经典论文
    -   GFS
    -   Bigtable
    -   Map reduce
-   重点看一下
    -   怎么描述问题和出发点（需求）
    -   怎么描述模型
    -   怎么描述系统架构



## 关于接口 interface

-   系统对外的**接口**，比系统实现本身还要重要
-   Why ?
    -   接口定义了**功能**：如果功能不正确，系统就没有用
    -   接口决定了**外部关系**，相对于内部，外部关系确定后非常**难修改**
-   哪些是接口
    -   模块对外的函数接口
    -   平台对外的API（很多是RPC或者Web API）
    -   系统间通信的协议（问题：什么是协议？）
    -   系统间存在依赖的数据（比如：给另外一个系统提供的词表）

>   什么是协议？
>
>   -    协议必须要有两个或多个参与者，也就是“协” 
>   -    协议是对参与者的一种行为约定和规范，也就是“议”。 



-   设计和修改接口，需要考虑的非常清楚
    -   设计时：合理、好用
    -   修改时需要尽量**向前兼容**



# 四、如何写好代码

## 代码也是一种表达方式

-   一个项目中，超过50%的时间用于沟通

-   现在，代码主要是写给人看的

    -   曾经要为机器考虑很多，但是现在编译器已经做了很多

    -   软件的维护成本远高于开发成本

        >   ​	在整个软件开发周期中，相比软件编写成本，软件维护成本是更高的，而在维护过程中，代码的可读性对维护效率影响非常大

-   编程规范，一般包含的内容

    -   代码如何规范表达：提高代码的可读性
    -   一些语言相关的注意事项：语言特性

-   理想的情况

    -   看别人的代码感觉和看自己的代码一样
    -   看代码时能够专注于逻辑，而不是格式
    -   Don’t make me think：不要带来额外的心智负担



## 模块

-   模块是程序的基本组成单位

    -   一个c文件（+h文件）、py文件、go package（一个目录）是一个模块

-   怎么切分模块是一个需要慎重考虑的事件

-   模块设计的原则

    -   **紧内聚、松耦合**

        >   如何实现？
        >
        >   -   单一目的
        >   -   明确对外接口（不允许全局变量这种方式访问）
        >   -   以数据为中心

-   好的模块划分是软件架构稳定的基础：主要是修改成本

    -   修改成本：建筑的框架 VS 内部装修

-   减少模块间的**耦合** == 》 降低软件**复杂性**：提供明确的对外接口！而不是隐含的方式

-   清晰的模块有利于代码的**复用**



## 切分模块的一种方法

-   数据类的模块
    -   实现对**数据的封装**
        -   模块内部变量
        -   类内部变量
    -   对外提供明确的**数据范问接口**
    -   写程序要以数据为中心考虑
        -   做模块划分时，首先考虑有哪些数据类的模块

-   过程的模块不包含数据
    -   本身**不包含数据**
    -   调用 数据类模块 或者 过程类模块 实现自身功能



## 模块切分的误区

误区1：所有代码放在一个模块中，因为规模太小了

>   -   切分代码的原则和代码规模没有关系
>   -   程序的规模在早期无法预估



误区2：把所有用到的附加功能都放在util模块中

>   -   util的存在和模块划分的原则是矛盾的
>   -   至少要细到file_util这样的粒度



误区3：从 过程 的角度出发考虑模块的切分

>   -   应该首先从 数据 的角度出发考虑





## 类和函数

-   类和函数是两种不同的模型，有它们各自适用的范围
    -   尽力想用一种方式来描述整个世界，这不是一个好主意
    -   Java的设计是一个反例：试图用对象来统一描述
-   推荐： 与类和对象无关的函数，作为一个独立的函数
    -   不建议实现为类的成员函数来写
    -   便于未来复用



## 函数

-   函数的切分也很重要

-   函数描述的3要素：给出明确的定义

    -   功能描述：这个函数是做什么的
    -   传入参数的描述：含义、限制参数
    -   返回值描述：各种可能性

    >   当你很难用一句话清晰的描述一个函数的功能时，这个函数其实就已经失控了，已经做不到单一职责了 

-   函数的规模，要足够的短小

    -   Python、Go：尽量在一屏内（约30行）完成
    -   C、C++：尽量在两屏内完成

-   写好程序的秘诀：把函数写的短一些

    -   Bug往往出现在哪些非常长的函数里



## 函数的返回值

-   每个函数应该有足够明确的语义
    -   基于函数的语义，函数返回值有4种类型
-   True、False
    -   逻辑判断型 的函数，表示 真 或 假
    -   如  isWhiteCat()
-   OK, ERROR
    -   操作型 函数，表示 成功 或 失败
    -   如 dateDelete()
-   Data，None
    -   获取数据型 的函数，不仅返回成功失败，还要把数据获取出来
    -   如 dateGet()
    -   Go的返回值形式：(data, error)
-   Value 
    -   数值计算 / 处理型 的函数
    -   如  calcXXXValue(input)



-   func()：不常用
    -   返回函数的函数



## 函数头的例子

-   函数头：对函数语义做出清晰和准确的说明
    -   函数功能的定义、进一步功能的说明
    -   参数的说明
    -   返回值的说明
    -   可能出现的错误说明



## 函数：单入口单出口

-   单入口、单出口是一种推荐的方式
-   多线程下数据表的实现
    -   使用一个内部函数来实现 **单入口单出口**

**不推荐：**

![1688993754255](02-%E4%BB%A3%E7%A0%81%E7%9A%84%E8%89%BA%E6%9C%AF.assets/1688993754255.png)

任何一处出现漏写锁释放都会造成很严重的后果



**推荐：**

![1688993779353](02-%E4%BB%A3%E7%A0%81%E7%9A%84%E8%89%BA%E6%9C%AF.assets/1688993779353.png)

通过包装一个单入口多出口的内部函数，对外提供一个单入口单出口的接口



## 代码块：代码布局

**Bad**

![1688994044549](02-%E4%BB%A3%E7%A0%81%E7%9A%84%E8%89%BA%E6%9C%AF.assets/1688994044549.png)

**Good：**

![1688994091529](02-%E4%BB%A3%E7%A0%81%E7%9A%84%E8%89%BA%E6%9C%AF.assets/1688994091529.png)

>   影响读者阅读代码消耗的时间，我们的时间应该要放在更有价值的地方



## 代码块

-   讨论范围：一个函数内的代码实现
-   思路：把代码的段落分清楚
-   形式的背后是逻辑（划分、层次）
    -   千万不要认为哪些 空行、空格 是可有可无的
-    Don’t make me think
    -   一眼看过来，如果无法看清楚逻辑，这不是好代码
    -   好的代码不需要你思考太多
    -   一定记住：**代码更是写给别人看的**
-   注释不是补出来的
    -   先写注释，后写代码：先把代码实现的目的写出来，然后写对应的代码（**自顶向下**）
-   Btw：
    -   一个在代码上表达不好的同学，在其他表达上一般也存在问题
    -   程序员 更需要提高的素质：语文和哲学



## 命名

-   命名的范围：系统、子系统、模块、函数、变量/常量
-   为什么命名如此重要？
    -   顾名思义 是人的自然反应
    -   概念是建立模型的出发点（概念，逻辑推理 == 》 模型体系）
-   普遍存在的问题：
    -   名字不携带信息：do，tmp，a，b….
    -   名字携带的信息是错误的：
        -   set()  vs update()
        -   isXXX() vs check()
-   命名不是一件容易的事情
    -   要求：准确、易懂
    -   起一个好名字很多时候需要**推敲**
    -   借用IDE进行重构



# 五、系统是运营出来的

## 在互联网时代，系统是运营出来的

-   系统的**可监测性**非常重要
-   如果没有足够的数据收集，系统等于没有上线
    -   在很多APP中其实做了大量的埋点，收集用户的使用数据，以此来决定产品后续的迭代方向
-   对一个系统来说，**数据和功能**同等重要
    -   功能可以依赖线下测试来验证
    -   数据只能依赖线上运转和运营
-   在设计和编码阶段，就要考虑系统的运营
    -   提供足够的状态记录
    -   提供方便的对外接口



## 举例：BFE

-   BFE的定位：为企业级使用场景而设计的七层负载均衡软件

![1689143099988](02-%E4%BB%A3%E7%A0%81%E7%9A%84%E8%89%BA%E6%9C%AF.assets/1689143099988.png)



## BFE的监控机制

-   基于日志监控的问题
    -   被监控系统的资源消耗较高
    -   监控系统的资源消耗较高
    -   很对状态信息并不适合打印输出
-   BFE的内部状态输出
    -   通过内嵌web server向外暴露
    -   状态信息的汇聚和读取成本低
-   可以将状态和日志配合使用
-   web Monitor框架
    -   https://github.com/baidu/go-lib
    -   支持状态、差值、延迟统计等



# 六、如何成为优秀的软件工程师

## 成为优秀的软件工程师的三条路径

-   一个好的程序员和以下因素没有必然的联系
    -   写了多少年程序
    -   写了多少行代码
    -   曾经在哪里上学、曾经在哪里工作
-   注意以下三个方面：
    -   学习——思考——实践
    -   知识——方法——精神
    -   基础乃治学之根本



## 学习——思考——实践

### 学习

-   软件编写历史已经超过半个世纪，有太多的经验可以被借鉴
-   途径：书、开源代码
-   有**hungry和foolish**的感觉才会去学习
    -   只有你感觉非常饥饿，而不是非常饱；只有你感觉非常笨，而不是非常聪明的时候才会去学习
    -   觉得自己什么都懂的人不会去学习
-   建议：努力建立起**学习的习惯和能力**



### 思考

-   学而不思则罔
-   不经过自己的思考，不能形成自己的思想，等于白学和白干



### 实践

-   知行合一
-   所有重要的进步，都来源于失败和挫折的经历



## 知识——方法——精神

### 知识

-   知识是过时最快的
-   只学习知识的人，总是感觉世界变化太快
-   编程语言、新的系统，…..



### 方法

-   虚（方法）可能比实（知识）更有价值
-   **分析问题、解决问题**的能力才是最重要的
-   Research(研究)：To Identify the Funcdamental Problem, and Solve it. 发现和证实关键的问题，并解决它



### 精神

-   前进的路上更多的是困难和荆棘
-   Don’t Follow：对完美的不懈追求



## 精神

-   自强不息，厚德载物
-   行胜于言
-   独立精神，自由思想



## 基础乃治学之根本

-   软件工程师的基础
    -   数据结构、算法；操作系统、系统结构、计算机网络
    -   软件工程、编程思想
    -   逻辑思维能力、归纳总结能力、表达能力
    -   研究能力：分析问题、解决问题



# 总结：

1.  软件工程师  != 码农
2.  代码可以是 **艺术品**，也可以是垃圾
3.  不要忘记我们为什么出发
    -   我们的目的是 **改变世界 / 格物致知**， 而不是学习编程，或炫耀技术
4.  好代码的来源不是写好代码
    -   好代码是一系列工作的结果
5.  代码是**写给别人**看的
    -   别人看不懂的代码是失败的
6.  写好代码是**有方法的**